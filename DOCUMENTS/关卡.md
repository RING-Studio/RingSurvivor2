# 关卡设计文档

## 关卡1 (Level1)

### 关卡结构
- **场景文件**: `scenes/Levels/Level1/Level1.tscn`
- **脚本文件**: `scenes/Levels/Level1/level1.gd`
- **地图中心**: `Vector2(220, 131)` (玩家初始位置)
- **EnemyManager**: 每个关卡实例化自己的 EnemyManager

### 区域划分 (Regions)
关卡包含一个 `Regions` 节点，其下包含多个 `Area2D` 用于检测玩家位置范围：

#### Region1_x 系列
- **区域节点**: `Region1_1`, `Region1_2`, `Region1_3`, `Region1_4`
- **点污染度计算公式**: `1000 + 全局污染度`
- **随机生成怪物上限公式**: `9 + 点污染度 / 1000`
- **随机生成怪物属性倍率公式**: `1.0 + 点污染度 / 1000`

#### Region2_x 系列
- **区域节点**: `Region2_1`, `Region2_2`, `Region2_3`, `Region2_4`
- **点污染度计算公式**: `1000 + 全局污染度 + 与地图中心距离`
- **随机生成怪物上限公式**: `10 + 点污染度 / 500`
- **随机生成怪物属性倍率公式**: `1.1 + 点污染度 / 500`

#### Region3
- **区域节点**: `Region3`
- **点污染度计算公式**: `3000 + 全局污染度`
- **随机生成怪物上限**: 固定为 `10`
- **随机生成怪物属性倍率公式**: `1.1 + 点污染度 / 500`
- **特殊机制**: 
  - **随机生成逻辑**: 使用独特的三人组生成方式，一次性生成 basic、basic、wizard 三人组，三人组位置较近（在同一个生成位置附近，偏移一定距离）
  - **BOSS 生成**: 当玩家进入 Region3 时，在固定位置（地图中心 `Vector2(220, 131)`）生成一个 BOSS
  - **BOSS 类型**: WizardEnemy（十倍属性，体型 scale 翻四倍）
  - **BOSS 属性调整**: BOSS 也会受到动态属性调整，即也会得到 `calculate_enemy_property_multiplier` 计算的属性加成
  - **BOSS 生成限制**: BOSS 只生成一次（进入时触发）

### 全局污染度
- **来源**: `GameManager.pollution` (在 `Scripts/Managers/gameManager.gd` 中定义)
- **用途**: 作为点污染度计算的基础值

### 实现要点
1. **区域检测**: 使用 Area2D 的 `body_entered` 和 `body_exited` 信号检测玩家进入/离开区域
2. **当前区域追踪**: EnemyManager 需要知道玩家当前所在的区域，以应用对应的规则
3. **点污染度计算**: 根据当前区域和玩家位置动态计算
4. **随机生成限制**: 需要追踪当前场景中随机生成的敌人数量，不超过上限
5. **固定位置生成**: Region3 的 BOSS 需要在玩家首次进入时生成，且只生成一次

---

## 实现方案

### 一、架构设计

#### 1. 区域检测机制
- **方案**: 在 `level1.gd` 中为每个 Region Area2D 连接信号，检测玩家进入/离开
- **信号处理**: 当玩家进入区域时，通知 EnemyManager 当前区域类型
- **区域类型枚举**: 
  - `REGION_TYPE_1` (Region1_x 系列)
  - `REGION_TYPE_2` (Region2_x 系列)
  - `REGION_TYPE_3` (Region3)
  - `REGION_TYPE_NONE` (不在任何区域)

#### 2. EnemyManager 改造

**新增 @export 变量**:
```gdscript
@export var map_center: Vector2 = Vector2(220, 131)  # 地图中心位置
```

**新增内部变量**:
```gdscript
var current_region_type: int = REGION_TYPE_NONE  # 当前区域类型
var random_enemy_count: int = 0  # 当前随机生成的敌人数量
var boss_spawned: bool = false  # Region3 BOSS 是否已生成
```

**新增方法**:
- `set_current_region(region_type: int)`: 设置当前区域类型
- `calculate_point_pollution() -> float`: 根据当前区域计算点污染度
- `calculate_max_random_enemies() -> int`: 根据点污染度计算随机生成上限
- `calculate_enemy_property_multiplier() -> float`: 根据点污染度计算属性倍率
- `spawn_boss()`: 在 Region3 生成 BOSS
- `track_enemy_spawned(enemy: Node2D)`: 追踪敌人生成
- `track_enemy_died(enemy: Node2D)`: 追踪敌人死亡

**修改现有方法**:
- `on_timer_timeout()`: 
  - 检查 `random_enemy_count` 是否达到上限
  - 使用新的属性倍率计算敌人属性
- `initialize_enemy_properties()`: 
  - 使用 `calculate_enemy_property_multiplier()` 计算倍率
  - 应用倍率到所有属性（生命值、伤害等）

#### 3. 区域检测实现 (level1.gd)

**新增方法**:
```gdscript
func _ready():
    # ... 现有代码 ...
    setup_region_detection()

func setup_region_detection():
    var regions_node = $Regions
    var enemy_manager = $EnemyManager
    
    # 连接所有 Region1_x 区域
    for i in range(1, 5):
        var region = regions_node.get_node_or_null("Region1_" + str(i))
        if region:
            region.body_entered.connect(_on_region1_entered)
            region.body_exited.connect(_on_region1_exited)
    
    # 连接所有 Region2_x 区域
    for i in range(1, 5):
        var region = regions_node.get_node_or_null("Region2_" + str(i))
        if region:
            region.body_entered.connect(_on_region2_entered)
            region.body_exited.connect(_on_region2_exited)
    
    # 连接 Region3
    var region3 = regions_node.get_node_or_null("Region3")
    if region3:
        region3.body_entered.connect(_on_region3_entered)
        region3.body_exited.connect(_on_region3_exited)

func _on_region1_entered(body):
    if body.is_in_group("player"):
        $EnemyManager.set_current_region(EnemyManager.REGION_TYPE_1)

func _on_region1_exited(body):
    if body.is_in_group("player"):
        # 检查是否还在其他 Region1_x 中
        # 如果不在任何区域，设置为 NONE
        pass

func _on_region2_entered(body):
    if body.is_in_group("player"):
        $EnemyManager.set_current_region(EnemyManager.REGION_TYPE_2)

func _on_region3_entered(body):
    if body.is_in_group("player"):
        $EnemyManager.set_current_region(EnemyManager.REGION_TYPE_3)
        # 触发 BOSS 生成（如果未生成）
        if not $EnemyManager.boss_spawned:
            $EnemyManager.spawn_boss()
```

### 二、核心算法

#### 1. 点污染度计算
```gdscript
func calculate_point_pollution() -> float:
    var global_pollution = GameManager.pollution
    
    match current_region_type:
        REGION_TYPE_1:
            return 1000.0 + global_pollution
        REGION_TYPE_2:
            var player = get_tree().get_first_node_in_group("player") as Node2D
            if player:
                var distance = player.global_position.distance_to(map_center)
                return 1000.0 + global_pollution + distance
            return 1000.0 + global_pollution
        REGION_TYPE_3:
            return 3000.0 + global_pollution
        _:
            return 0.0  # 默认值，不应该发生
```

#### 2. 随机生成上限计算
```gdscript
func calculate_max_random_enemies() -> int:
    var point_pollution = calculate_point_pollution()
    
    match current_region_type:
        REGION_TYPE_1:
            return int(9 + point_pollution / 1000.0)
        REGION_TYPE_2:
            return int(10 + point_pollution / 500.0)
        REGION_TYPE_3:
            return 10  # 固定值
        _:
            return 0
```

#### 3. 属性倍率计算
```gdscript
func calculate_enemy_property_multiplier() -> float:
    var point_pollution = calculate_point_pollution()
    
    match current_region_type:
        REGION_TYPE_1:
            return 1.0 + point_pollution / 1000.0
        REGION_TYPE_2, REGION_TYPE_3:
            return 1.1 + point_pollution / 500.0
        _:
            return 1.0
```

#### 4. BOSS 生成
```gdscript
func spawn_boss():
    if boss_spawned:
        return
    
    boss_spawned = true
    var boss = wizard_enemy_scene.instantiate() as WizardEnemy
    
    var entities_layer = get_tree().get_first_node_in_group("entities_layer")
    entities_layer.add_child(boss)
    boss.global_position = map_center
    
    # 设置 BOSS 属性（十倍属性）
    var multiplier = 10.0
    var properties = {
        "max_health": 30.0 * multiplier,  # WizardEnemy 基础生命值 * 10
        "base_damage": 1 * multiplier,
        # ... 其他属性也乘以 10
    }
    boss.initialize_enemy(properties)
    
    # 设置体型 scale 翻四倍
    boss.scale = Vector2(4.0, 4.0)
    
    # 追踪 BOSS（不计入随机生成数量）
```

### 三、敌人追踪机制

#### 1. 追踪随机生成的敌人
- 在 `on_timer_timeout()` 中，每次生成敌人后调用 `track_enemy_spawned(enemy)`
- 敌人死亡时，需要通知 EnemyManager（可以通过信号或 EnemyManager 监听敌人死亡）

#### 2. 敌人死亡检测
- 方案1: EnemyManager 在 `_process` 中遍历 entities_layer，统计存活敌人
- 方案2: 敌人死亡时发送信号，EnemyManager 监听并更新计数
- **推荐方案2**，性能更好

### 四、与现有系统的兼容性

#### 1. ArenaTimeManager 集成
- 保留 `arena_difficulty` 系统，但主要用于时间相关的难度调整
- 点污染度系统独立于 `arena_difficulty`，用于区域相关的难度调整

#### 2. 属性初始化
- `initialize_enemy_properties()` **只使用区域污染度倍率**，不再考虑 `arena_difficulty`
- 最终属性 = 基础属性 × `calculate_enemy_property_multiplier()`
- BOSS 也会受到动态属性调整（区域污染度倍率）
  - BOSS 最终属性 = 基础属性 × 10.0（BOSS 基础倍率）× `calculate_enemy_property_multiplier()`（区域污染度倍率）

#### 3. 怪物标签系统
- **随机生成怪物**: 添加到 `"random_enemy"` 组，计入上限统计
- **固定生成怪物**: 添加到 `"fixed_enemy"` 组（如 BOSS），不计入上限统计
- **Region3 三人组**: 三人组中的所有怪物都是随机生成的，都会计入上限统计（+3）

#### 4. Region3 特殊生成逻辑
- Region3 的随机生成使用独特的逻辑：
  - 一次性生成三人组：basic、basic、wizard
  - 三人组位置较近（在同一个生成位置附近，偏移一定距离，偏移半径为 50.0）
  - 三人组作为一个整体计入随机生成数量（+3）
  - 生成前需要检查是否有足够空间（至少需要 3 个空位）

### 五、实现步骤

1. **第一步**: 在 `enemy_manager.gd` 中添加区域类型枚举和基础变量
2. **第二步**: 实现点污染度、上限、倍率计算函数
3. **第三步**: 修改 `on_timer_timeout()` 添加上限检查
4. **第四步**: 修改 `initialize_enemy_properties()` 应用区域倍率
5. **第五步**: 实现敌人追踪机制（生成/死亡）
6. **第六步**: 在 `level1.gd` 中实现区域检测逻辑
7. **第七步**: 实现 BOSS 生成逻辑
8. **第八步**: 测试和调试

### 六、注意事项

1. **区域重叠**: 如果玩家同时在多个区域中，需要优先级处理（Region3 > Region2 > Region1）
2. **区域切换**: 区域切换时，需要重新计算上限和倍率
3. **敌人计数**: 需要区分随机生成的敌人和固定位置生成的敌人（BOSS）
4. **性能优化**: 敌人计数可以考虑使用信号机制，避免每帧遍历
5. **地图中心**: 每个关卡的地图中心可能不同，需要在场景中配置
