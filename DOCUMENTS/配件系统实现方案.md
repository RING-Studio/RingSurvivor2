# 配件系统核心实现方案

## 一、数据结构扩展

### 1.1 AbilityUpgradeData.entries 扩展

为每个升级条目添加以下字段：
- `upgrade_type`: `"enhancement"` | `"accessory"` - 区分强化和配件
- `exclusive_for`: `""` | `"mg"` | `"mine"` - 专属标识（空字符串表示非专属）

新增条目：
```gdscript
# 配件
{
    "id": "mine",
    "name": "地雷",
    "description": "放置一个地雷，接触敌人后对{爆炸范围}米范围内敌人造成{基础伤害=5lv}点伤害。\\n基础装填间隔：{冷却时间}秒\\n部署上限：{mine_max_deployed_value}",
    "quality": "blue",
    "max_level": 4,
    "upgrade_type": "accessory",
    "exclusive_for": ""
},
{
    "id": "cooling_device",
    "name": "冷却装置",
    "description": "所有【冷却类】配件冷却速度 +{cooling_device_value}%",
    "quality": "red",
    "max_level": 3,
    "upgrade_type": "accessory",
    "exclusive_for": ""
},
# 地雷专属强化
{
    "id": "mine_range",
    "name": "地雷·范围",
    "description": "地雷爆炸范围+{mine_range_value}米",
    "quality": "blue",
    "max_level": 5,
    "upgrade_type": "enhancement",
    "exclusive_for": "mine"
},
{
    "id": "mine_cooldown",
    "name": "地雷·装填速度",
    "description": "地雷装填速度 +{mine_cooldown_value}%",
    "quality": "blue",
    "max_level": 5,
    "upgrade_type": "enhancement",
    "exclusive_for": "mine"
},
{
    "id": "mine_multi_deploy",
    "name": "地雷·布雷",
    "description": "地雷基础伤害 -{mine_multi_damage_penalty}\\n每次部署地雷数量 +{mine_multi_deploy_count}",
    "quality": "purple",
    "max_level": 4,
    "upgrade_type": "enhancement",
    "exclusive_for": "mine"
},
{
    "id": "mine_anti_tank",
    "name": "地雷·AT",
    "description": "地雷装填间隔 +5秒，地雷基础伤害+{mine_anti_tank_value}%。地雷仅能由精英或BOSS触发",
    "quality": "purple",
    "max_level": 5,
    "upgrade_type": "enhancement",
    "exclusive_for": "mine"
}
```

为现有机炮专属强化添加字段：
```gdscript
{
    "id": "mg_overload",
    ...
    "exclusive_for": "mg"  # 新增
},
{
    "id": "mg_heavy_round",
    ...
    "exclusive_for": "mg"  # 新增
},
{
    "id": "mg_he_round",
    "name": "机炮·高爆弹",
    "description": "主武器基础伤害+3，穿透固定为1",
    ...
    "exclusive_for": "mg"  # 新增
}
```

### 1.2 UpgradeManager 数据结构

```gdscript
# 升级池数据库：存储所有升级条目（包括专属强化）
var upgrade_database: Dictionary = {}

# 局内升级池：当前对局中实际可抽取的升级
var active_pools: Dictionary = {
    "white": WeightedTable.new(),
    "blue": WeightedTable.new(),
    "purple": WeightedTable.new(),
    "red": WeightedTable.new()
}

# 已装备的配件列表（局内）
var session_equipped_accessories: Array[String] = []
```

### 1.3 UpgradeEffectManager 扩展

添加地雷相关配置：
```gdscript
"mine": {
    "type": "linear",
    "per_level_value": 1.0,
    "max_level": 4
},
"mine_range": {
    "type": "linear",
    "per_level_value": 1.5,  # 米
    "max_level": 5
},
"mine_cooldown": {
    "type": "linear",
    "per_level_value": 0.15,  # 15%
    "max_level": 5
},
"mine_anti_tank": {
    "type": "linear",
    "per_level_value": 2.0,  # 200%
    "max_level": 5
},
"cooling_device": {
    "type": "linear",
    "per_level_value": 0.15,  # 15%
    "max_level": 3
}
```

---

## 二、升级池动态管理

### 2.1 数据库初始化（全局，在autoload或单例中）

**设计思路**：升级数据库应该在游戏启动时就初始化，可以在任何场景中访问，支持任务前的武器/配件选择界面。

```gdscript
# 在 UpgradeManager 中
var upgrade_database: Dictionary = {}
var database_initialized: bool = false

func initialize_database():
    """初始化升级数据库（所有升级条目，包括专属强化）"""
    if database_initialized:
        return
    
    for entry in AbilityUpgradeData.entries:
        var upgrade_id = entry["id"]
        upgrade_database[upgrade_id] = entry.duplicate()
        if not GameManager.current_upgrades.has(upgrade_id):
            GameManager.current_upgrades[upgrade_id] = {"level": 0}
    
    database_initialized = true

func _ready():
    # 初始化数据库（全局，只初始化一次）
    initialize_database()
    GameEvents.level_up.connect(on_level_up)
```

### 2.2 局内升级池初始化（进入任务时）

**设计思路**：局内升级池应该在进入任务时初始化，根据当前装备状态（主武器、已选配件）动态构建。

```gdscript
func initialize_active_pools():
    """初始化局内升级池（根据当前装备状态）"""
    # 清空现有池子
    for quality in active_pools:
        active_pools[quality] = WeightedTable.new()
    
    # 获取当前主武器（从vehicle_config或session状态）
    var vehicle_config = GameManager.get_vehicle_config(GameManager.current_vehicle)
    var main_weapon_id = vehicle_config.get("主武器类型", null)
    
    # 获取已装备的配件（局内+局外）
    var equipped_accessories = session_equipped_accessories.duplicate()
    # 如果支持局外携带，也需要从vehicle_config读取
    var vehicle_accessories = vehicle_config.get("配件", [])
    # 将局外配件ID转换为字符串ID（如果需要）
    # ...
    
    # 遍历数据库，决定哪些加入局内池
    for upgrade_id in upgrade_database:
        var entry = upgrade_database[upgrade_id]
        var exclusive_for = entry.get("exclusive_for", "")
        
        # 检查专属条件
        var should_add = true
        if exclusive_for == "mg":
            should_add = (main_weapon_id == 1)  # 机炮ID=1
        elif exclusive_for == "mine":
            should_add = ("mine" in equipped_accessories)
        
        if should_add:
            var quality = entry.get("quality", "white")
            var current_level = GameManager.current_upgrades.get(upgrade_id, {}).get("level", 0)
            var max_level = entry.get("max_level", -1)
            
            # 未满级才加入
            if max_level == -1 or current_level < max_level:
                active_pools[quality].add_item(upgrade_id, 1)

# 在进入任务时调用（例如在Level1.gd的_ready中）
func start_session():
    """开始新对局时调用"""
    session_equipped_accessories.clear()
    initialize_active_pools()
```

### 2.2 动态添加专属强化

```gdscript
func _add_exclusive_upgrades_for_accessory(accessory_id: String):
    """当玩家选择配件后，将其专属强化加入局内池"""
    if not database_initialized:
        initialize_database()
    
    for upgrade_id in upgrade_database:
        var entry = upgrade_database[upgrade_id]
        if entry.get("exclusive_for", "") == accessory_id:
            var quality = entry.get("quality", "white")
            var current_level = GameManager.current_upgrades.get(upgrade_id, {}).get("level", 0)
            var max_level = entry.get("max_level", -1)
            
            # 检查是否已在池中（避免重复添加）
            var already_in_pool = false
            for item in active_pools[quality].items:
                if item["item"] == upgrade_id:
                    already_in_pool = true
                    break
            
            if not already_in_pool and (max_level == -1 or current_level < max_level):
                active_pools[quality].add_item(upgrade_id, 1)

func _add_exclusive_upgrades_for_weapon(weapon_id: int):
    """当玩家装备主武器后，将其专属强化加入局内池"""
    if not database_initialized:
        initialize_database()
    
    var exclusive_prefix = ""
    match weapon_id:
        1:  # 机炮
            exclusive_prefix = "mg"
        # 其他武器...
    
    if exclusive_prefix == "":
        return
    
    for upgrade_id in upgrade_database:
        var entry = upgrade_database[upgrade_id]
        if entry.get("exclusive_for", "") == exclusive_prefix:
            var quality = entry.get("quality", "white")
            var current_level = GameManager.current_upgrades.get(upgrade_id, {}).get("level", 0)
            var max_level = entry.get("max_level", -1)
            
            var already_in_pool = false
            for item in active_pools[quality].items:
                if item["item"] == upgrade_id:
                    already_in_pool = true
                    break
            
            if not already_in_pool and (max_level == -1 or current_level < max_level):
                active_pools[quality].add_item(upgrade_id, 1)
```

### 2.3 apply_upgrade 修改

```gdscript
func apply_upgrade(upgrade_id: String):
    if not GameManager.current_upgrades.has(upgrade_id):
        GameManager.current_upgrades[upgrade_id] = {"level": 0}

    var entry = upgrade_database.get(upgrade_id)
    if entry == null:
        push_warning("无法找到升级数据: %s" % upgrade_id)
        return
    
    var upgrade_type = entry.get("upgrade_type", "enhancement")
    
    # 处理配件
    if upgrade_type == "accessory":
        if upgrade_id not in session_equipped_accessories:
            # 首次获得配件
            session_equipped_accessories.append(upgrade_id)
            GameManager.current_upgrades[upgrade_id]["level"] = 1
            
            # 添加该配件的专属强化到池中
            _add_exclusive_upgrades_for_accessory(upgrade_id)
        else:
            # 已拥有，升级
            GameManager.current_upgrades[upgrade_id]["level"] += 1
    else:
        # 处理强化
        GameManager.current_upgrades[upgrade_id]["level"] += 1
    
    # 检查是否满级，从局内池移除
    var max_level = entry.get("max_level", 0)
    if max_level != -1 and GameManager.current_upgrades[upgrade_id]["level"] >= max_level:
        var quality = entry.get("quality", "white")
        active_pools[quality].remove_item(upgrade_id)
    
    # 处理互斥逻辑
    _handle_fire_direction_exclusivity(upgrade_id)
    
    # 每次升级增加1个roll点
    GameManager.roll_points += 1
    
    GameEvents.emit_ability_upgrade_added(upgrade_id, GameManager.current_upgrades)
```

### 2.4 pick_upgrades 修改

```gdscript
func pick_upgrades() -> Array[Dictionary]:
    """从局内升级池中抽取（不再过滤）"""
    var chosen_upgrades: Array[Dictionary] = []
    var exclude: Array[String] = []
    
    var current_level = 1
    if experience_manager != null:
        current_level = experience_manager.current_level
    
    for i in 3:
        var quality = _pick_quality_with_retry(current_level, exclude)
        if quality == "":
            break
        
        # 从局内池中抽取
        var chosen_id = active_pools[quality].pick_item(exclude)
        if chosen_id == null:
            break
        
        exclude.append(chosen_id)
        var entry = upgrade_database.get(chosen_id)
        if entry != null:
            chosen_upgrades.append(entry)
    
    return chosen_upgrades
```

---

## 三、地雷Controller实现

### 3.1 MineAbilityController 结构

```gdscript
extends Node
class_name MineAbilityController

@export var mine_scene: PackedScene
@export var base_cooldown: float = 3.0  # 基础装填间隔（秒）
@export var base_explosion_radius: float = 48.0  # 基础爆炸范围（像素，3米 * 16像素/米）
@export var base_damage: float = 5.0  # 基础伤害（每级5点）

var mine_timer: Timer
var deployed_mines: Array[Node2D] = []  # 已部署的地雷列表（FIFO队列）

func _ready():
    mine_timer = Timer.new()
    mine_timer.wait_time = _get_load_interval_seconds()
    mine_timer.timeout.connect(_on_timer_timeout)
    mine_timer.autostart = true
    add_child(mine_timer)
    
    GameEvents.ability_upgrade_added.connect(_on_upgrade_added)

func _get_load_interval_seconds() -> float:
    """计算当前装填间隔（秒）。装填/冷却统一按“速度加成”计算：间隔 = 基础间隔 / (1 + 速度加成)。"""
    var base_interval_seconds := base_cooldown
    
    # 地雷·AT：装填间隔 +5秒（作为基础间隔惩罚，仍会被装填速度加成缩短）
    var anti_tank_level = GameManager.current_upgrades.get("mine_anti_tank", {}).get("level", 0)
    if anti_tank_level > 0:
        base_interval_seconds += 5.0
    
    # 地雷·装填速度：+15% per level（速度加成）
    var load_speed_bonus := 0.0
    var cooldown_level = GameManager.current_upgrades.get("mine_cooldown", {}).get("level", 0)
    if cooldown_level > 0:
        load_speed_bonus += UpgradeEffectManager.get_effect("mine_cooldown", cooldown_level)
    
    # 注意：冷却装置只影响【冷却类】配件，不作用于地雷（地雷使用装填）
    var speed_multiplier := max(1.0 + load_speed_bonus, 0.05)
    var interval := base_interval_seconds / speed_multiplier
    return max(interval, 0.1)  # 最小0.1秒

func _get_mines_per_deploy() -> int:
    """每次装填触发时部署的地雷数量"""
    var level = GameManager.current_upgrades.get("mine_multi_deploy", {}).get("level", 0)
    return max(1 + level, 1)

func _get_max_deployed() -> int:
    """获取最大部署数量"""
    var mine_level = GameManager.current_upgrades.get("mine", {}).get("level", 0)
    if mine_level == 0:
        mine_level = 1
    return 10 + 5 * mine_level

func _get_explosion_radius() -> float:
    """获取爆炸范围"""
    var radius = base_explosion_radius
    var range_level = GameManager.current_upgrades.get("mine_range", {}).get("level", 0)
    if range_level > 0:
        radius += UpgradeEffectManager.get_effect("mine_range", range_level) * 16.0  # 转换为像素（1米=16像素）
    return radius

func _get_base_damage() -> float:
    """获取基础伤害"""
    var mine_level = GameManager.current_upgrades.get("mine", {}).get("level", 0)
    if mine_level == 0:
        mine_level = 1
    var damage = base_damage * mine_level
    
    # 地雷·布雷：基础伤害 -1 per level（在AT倍率前生效）
    var multi_deploy_level = GameManager.current_upgrades.get("mine_multi_deploy", {}).get("level", 0)
    if multi_deploy_level > 0:
        damage -= float(multi_deploy_level)
        damage = max(damage, 1.0)
    
    # 地雷·AT：+200% per level
    var anti_tank_level = GameManager.current_upgrades.get("mine_anti_tank", {}).get("level", 0)
    if anti_tank_level > 0:
        var multiplier = UpgradeEffectManager.get_effect("mine_anti_tank", anti_tank_level)
        damage *= (1.0 + multiplier)
    
    return damage

func _on_timer_timeout():
    var player = get_tree().get_first_node_in_group("player")
    if player == null:
        return
    
    var deploy_count := _get_mines_per_deploy()
    for i in range(deploy_count):
        # 检查部署上限（逐个处理，避免一次性部署超过上限）
        var max_deployed = _get_max_deployed()
        if deployed_mines.size() >= max_deployed:
            # 触发最早的地雷爆炸
            var oldest_mine = deployed_mines[0]
            if is_instance_valid(oldest_mine):
                oldest_mine.trigger_explosion()
            deployed_mines.remove_at(0)
        
        # 部署新地雷（多枚时做轻微散布，避免完全重叠）
        var offset = Vector2.RIGHT.rotated(randf_range(0.0, TAU)) * randf_range(0.0, 16.0)
        _deploy_mine(player.global_position + offset)
    
    # 更新计时器
    mine_timer.wait_time = _get_load_interval_seconds()
    mine_timer.start()

func _deploy_mine(position: Vector2):
    """部署地雷"""
    var mine_instance = mine_scene.instantiate()
    # 实例化到foreground_layer，与机炮子弹一致
    get_tree().get_first_node_in_group("foreground_layer").add_child(mine_instance)
    mine_instance.global_position = position
    mine_instance.setup(
        _get_explosion_radius(),
        _get_base_damage(),
        GameManager.current_upgrades.get("mine_anti_tank", {}).get("level", 0) > 0
    )
    mine_instance.exploded.connect(_on_mine_exploded)
    deployed_mines.append(mine_instance)

func _on_mine_exploded(mine: Node2D):
    """地雷爆炸回调"""
    deployed_mines.erase(mine)

func _on_upgrade_added(upgrade_id: String, current_upgrades: Dictionary):
    """升级添加时更新"""
    if upgrade_id in ["mine", "mine_cooldown", "mine_anti_tank"]:
        mine_timer.wait_time = _get_load_interval_seconds()
        mine_timer.start()
```

### 3.2 Mine 节点实现

```gdscript
extends Area2D
class_name Mine

signal exploded(mine: Mine)

@onready var sprite: Sprite2D = $Sprite2D
@onready var explosion_area: CollisionShape2D = $ExplosionArea/CollisionShape2D

var explosion_radius: float
var base_damage: float
var elite_only: bool = false  # 是否仅精英/BOSS触发

func setup(radius: float, damage: float, elite_only_flag: bool):
    explosion_radius = radius
    base_damage = damage
    elite_only = elite_only_flag
    
    # 设置爆炸范围
    if explosion_area.shape is CircleShape2D:
        explosion_area.shape.radius = radius
    
    body_entered.connect(_on_body_entered)

func _on_body_entered(body: Node2D):
    if not body.is_in_group("enemy"):
        return
    
    # 检查是否仅精英/BOSS触发
    if elite_only:
        var is_elite = body.get("is_elite") == true
        var is_boss = body.get("is_boss") == true
        if not is_elite and not is_boss:
            return
    
    # 触发爆炸
    trigger_explosion()

func trigger_explosion():
    """触发爆炸"""
    # 获取范围内所有敌人
    var enemies = []
    var explosion_area_node = get_node_or_null("ExplosionArea")
    if explosion_area_node:
        var overlapping_bodies = explosion_area_node.get_overlapping_bodies()
        for body in overlapping_bodies:
            if body.is_in_group("enemy"):
                enemies.append(body)
    
    # 对每个敌人造成伤害
    for enemy in enemies:
        _deal_damage_to_enemy(enemy)
    
    # 播放爆炸效果
    _play_explosion_effect()
    
    # 发出信号并移除
    exploded.emit(self)
    queue_free()

func _deal_damage_to_enemy(enemy: Node2D):
    """对敌人造成伤害（走护甲计算）"""
    # 应用伤害加成（伤害强化影响所有伤害来源，包括配件）
    var damage_bonus_level = GameManager.current_upgrades.get("damage_bonus", {}).get("level", 0)
    if damage_bonus_level > 0:
        damage *= (1.0 + UpgradeEffectManager.get_effect("damage_bonus", damage_bonus_level))
    
    # 计算暴击
    var base_crit_rate = GameManager.get_global_crit_rate()
    var crit_damage_multiplier = 2.0  # 默认暴击伤害倍率
    
    # 应用暴击伤害加成
    var crit_damage_level = GameManager.current_upgrades.get("crit_damage", {}).get("level", 0)
    if crit_damage_level > 0:
        crit_damage_multiplier += UpgradeEffectManager.get_effect("crit_damage", crit_damage_level)
    
    var is_critical = randf() < base_crit_rate
    var damage_type = "accessory"
    
    if is_critical:
        damage *= crit_damage_multiplier
        damage_type = "accessory_critical"
    
    # 走护甲计算
    var final_damage = GlobalFomulaManager.calculate_damage(
        damage,
        GameManager.get_player_hard_attack_multiplier_percent(),
        GameManager.get_player_soft_attack_multiplier_percent(),
        GameManager.get_player_hard_attack_depth_mm(),
        enemy.get("armor_thickness", 0),
        enemy.get("armor_coverage", 0.0),
        enemy.get("hardAttackDamageReductionPercent", 0.0)
    )
    
    # 应用伤害
    var hurtbox = enemy.get_node_or_null("HurtboxComponent")
    if hurtbox:
        hurtbox.apply_damage(final_damage, damage_type)

func _play_explosion_effect():
    """播放爆炸效果（可选）"""
    # TODO: 添加爆炸动画/粒子效果
    pass
```

---

## 四、伤害类型系统重构（二元标签）

### 4.1 伤害类型结构设计

**设计思路**：使用二元标签系统，分离伤害来源和是否暴击。

```gdscript
# 伤害来源类型
enum DamageSource {
    WEAPON,      # 武器伤害
    ACCESSORY,   # 配件伤害
    BLEED        # 流血伤害
}

# 伤害类型结构（可选：使用Dictionary或单独参数）
# 方案1：使用Dictionary
var damage_info = {
    "source": DamageSource.WEAPON,
    "is_critical": false
}

# 方案2：使用两个独立参数（推荐，更简单）
# apply_damage(amount, source, is_critical)
```

### 4.2 HurtboxComponent 修改

```gdscript
func apply_damage(amount: float, damage_source: String = "weapon", is_critical: bool = false):
    """
    应用伤害
    damage_source: "weapon" | "accessory" | "bleed"
    is_critical: 是否暴击
    """
    var floating_text = floating_text_scene.instantiate() as Node2D
    get_tree().get_first_node_in_group("foreground_layer").add_child(floating_text)
    floating_text.global_position = global_position + (Vector2.UP * 16)
    
    if health_component != null:
        health_component.damage(amount)
    
    var format_string = "%0.1f"
    if round(amount) == amount:
        format_string = "%0.0f"
    
    # 根据伤害来源和是否暴击确定颜色
    var color = DamageTextHelper.get_color(damage_source, is_critical)
    floating_text.call_deferred("start", format_string % amount, color)
    
    # 只有 weapon 类型伤害才触发 hit 信号（用于播放音效）
    if damage_source == "weapon":
        hit.emit()
```

### 4.3 DamageTextHelper 重构

```gdscript
extends Node

# 伤害来源颜色映射
var SOURCE_COLORS := {
    "weapon": Color(1, 1, 1, 1),      # 白色
    "accessory": Color(1, 1, 1, 1),  # 白色（与武器相同）
    "bleed": Color(0.9, 0.2, 0.4, 1) # 绯红色
}

# 暴击颜色（覆盖伤害来源颜色）
var CRITICAL_COLOR := Color(1, 0.93, 0.2, 1)  # 黄色

func get_color(damage_source: String, is_critical: bool = false) -> Color:
    """
    获取伤害数字颜色
    damage_source: "weapon" | "accessory" | "bleed"
    is_critical: 是否暴击
    """
    if is_critical:
        return CRITICAL_COLOR
    
    return SOURCE_COLORS.get(damage_source, SOURCE_COLORS["weapon"])
```

### 4.4 现有代码修改

**MachineGunAbility.gd**:
```gdscript
# 修改前
apply_damage_to_hurtbox(hurtbox, damage, damage_type)

# 修改后
var damage_source = "weapon"
var is_critical = false
if damage_type == "critical":
    is_critical = true
apply_damage_to_hurtbox(hurtbox, damage, damage_source, is_critical)
```

**Mine.gd**:
```gdscript
# 地雷伤害
var damage_source = "accessory"
var is_critical = randf() < base_crit_rate

# 应用伤害
hurtbox.apply_damage(final_damage, damage_source, is_critical)
```

---

## 五、配件系统集成

### 5.1 Player.gd 修改

在 `setup_equipped_abilities` 中添加配件Controller的初始化：

```gdscript
func setup_equipped_abilities():
    """根据当前车辆配装设置Ability"""
    var vehicle_config = GameManager.get_vehicle_config(GameManager.current_vehicle)
    if vehicle_config == null:
        return

    # 主武器
    var main_weapon_id = vehicle_config.get("主武器类型")
    if main_weapon_id != null:
        match main_weapon_id:
            1:  # 机炮
                var machine_gun_controller = preload("res://scenes/ability/machine_gun_ability_controller/machine_gun_ability_controller.tscn").instantiate()
                abilities.add_child(machine_gun_controller)
    
    # 配件（从局内已装备列表）
    var upgrade_manager = get_tree().get_first_node_in_group("upgrade_manager")
    if upgrade_manager and upgrade_manager.has_method("get_session_equipped_accessories"):
        var equipped_accessories = upgrade_manager.get_session_equipped_accessories()
        
        for accessory_id in equipped_accessories:
            match accessory_id:
                "mine":
                    var mine_controller = preload("res://scenes/ability/mine_ability_controller/mine_ability_controller.tscn").instantiate()
                    abilities.add_child(mine_controller)
                # 其他配件...
```

---

## 六、实现步骤

1. **数据结构扩展**（阶段0）
   - 扩展 `AbilityUpgradeData.entries`，添加新配件和专属强化
   - 添加 `upgrade_type` 和 `exclusive_for` 字段
   - 扩展 `UpgradeEffectManager` 配置

2. **升级池动态管理**（阶段1）
   - 重构 `UpgradeManager`，分离数据库和局内池
   - 实现动态添加/移除逻辑
   - 修改 `apply_upgrade` 和 `pick_upgrades`

3. **地雷Controller实现**（阶段2）
   - 创建 `MineAbilityController`
   - 创建 `Mine` 节点（地雷实体）
   - 实现部署上限触发机制
   - 集成到 `Player.setup_equipped_abilities`

4. **伤害类型系统扩展**（阶段3）
   - 扩展 `DamageTextHelper`，添加配件伤害类型
   - 确保地雷伤害走护甲计算

5. **测试与优化**（阶段4）
   - 测试地雷部署、爆炸、上限触发
   - 测试专属强化动态加入
   - 测试配件冷却全局效果

---

## 七、注意事项

1. **地雷图片资源**：`Assets/GPT/ChatGPT Mine.png` 已准备好
2. **地雷基础数值**：需要在实现时确定基础冷却时间、爆炸范围等
3. **敌人类型标记**：需要确保敌人有 `is_elite` 和 `is_boss` 属性，用于地雷·反甲的判定
4. **局内/局外配件**：当前实现只处理局内配件，局外携带功能后续扩展
